# Netpractice

## 컴퓨터 네트워크
> 분산되어 있는 컴퓨터를 통신망으로 연결하여 통신하는 것을 말한다. 각각의 컴퓨터 (호스트)는 통신 프로트콜이라는 규칙 시스템을 지키며 물리적 또는 무선 기술(유선 및 무선 통신)을 통해 데이터를 교환한다.

## 컴퓨터 네트워크 아키텍처
> 컴퓨터 네트워크 아키텍처 설계는 두가지로 나뉘며 client-server 구조 혹은 p2p 구조를 따른다.

> client-server 구조 : 서버는 클라이언트들이 필요한 리소스를 제공하며 연산 처리 기능도 맡는다. 클라이언트끼리는 서로 통신이 가능하지만 리소스를 공유하지는 않는다. 즉, 데이터 엑세스는 서버를 통해서만 가능하다.

> p2p 구조 : 서버와 클라이언트의 구분이 없으며 (피어라고 부른다) 각 피어는 동등한 권한을 가지고 리소스 공유 역시 피어끼리 진행한다.

> 차이점 : 클라이언트-서버 구조에서는 클라이언트의 수가 많을 경우 병목 현상(특정 클라이언트에서의 자원 처리가 늦을 경우 다른 클라이언트의 자원 처리 시간에 영향을 끼침)가 일어날 수 있지만 p2p 구조는 서버가 피어 수만큼 있기 때문에
연산 작업이 분산되어 병목 현상이 적다. 안전성 면에서는 검증된 서버에 의해 리소스를 제공받고 접근 기록을 관리받는 클라이언트에 비해 p2p 구조에서는 사용자끼리 리소스를 주고 받으므로 보안적 측면에서 위험하다고 볼 수 있다.

> <img width="759" alt="스크린샷 2024-01-31 오후 10 46 13" src="https://github.com/sejkim2/42seoul/assets/128696540/c8b8c033-c264-429b-9ab7-c2b79d9e5f67">

## 호스트
> 컴퓨터 네트워크에 연결된 컴퓨터, 즉 서로 통신이 가능한 컴퓨터를 말한다. (출처 : http://www.codns.com/b/B05-156)

## OSI 7 계층, IP/TCP 4 계층
> <img width="359" alt="스크린샷 2024-01-31 오후 11 28 36" src="https://github.com/sejkim2/42seoul/assets/128696540/12962687-d332-4f6e-b81c-862c9b4d6096">

> 네트워크 관리를 독립적으로 운영하기 위해 도입된 구조 체제 (각 계층은 다른 계층에 독립적이며 이는 유지 보수에 유리하다)

## Physical (1계층)
> 논리 데이터를 물리적으로 전송하는 계층, 하드웨어적 기술이 주를 이루고 있다.
> 대표적인 장비로는 리피터, 허브 등이 있다.

> ## 리피터
> 케이블이 길수록 신호가 약해지기 때문에 신호를 증폭시키기 위한 장치
> 허브에 리피터 기능이 있기에 잘 쓰이지 않는다.

> <img width="643" alt="Screen Shot 2024-02-01 at 6 05 40 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/7994ca6f-2338-4165-a2f8-ac29e679feb0">

> ## 허브
> 리피터의 역할을 하지만 여러 장비와 연결 가능하다.
> 주소를 고려하지 않는 브로드캐스트 전송 방식을 사용하며 출발지와 목적지에 대한 정보를 가지고 있지 않다.
> 허브는 데이터를 연결된 모든 기기에 전달(브로드캐스트)하기 때문에 동시 전송 시 데이터 충돌이 일어날 수 있다.
> 모든 포트 간 대역폭을 나누어 사용하기 때문에 연결된 기기가 많을 수록 성능 저하가 발생한다.
> MAC 주소 기반으로 데이터를 전송하는 스위치의 등장으로 허브는 현재 소규모 네트워크에서만 사용된다.

> <img width="461" alt="Screen Shot 2024-02-01 at 6 08 33 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/04bfeefa-701a-477b-a588-ccf9ff131359">

## Datalink (2계층)
> 물리 계층에서 전달받은 데이터의 주소를 할당하고 물리 계층에서 발생할 수 있는 오류를 찾아 수정하여 재전송한다.
> ## 에러 제어
>> 페리트 비트
>>> 1의 개수를 짝수 개로 맞춰 보낼지(짝수 페리티) 홀수 개로 맞춰 보낼지(홀수 페리티) 송/수신 측이 약속하여 그에 맞게 페리트 비트를 채워 보내 바뀐 비트가 있는지 확인하는 방법. 2bit 이상의 손실 시 홀수와 짝수 검사 의미가 없으며(정확히는 짝수 개일 경우 알 수가 없다) 오류가 발생한 위치를 알 수 없으므로 수정 또한 불가능하다.

>> CRC(순환 중복 검사)
>>> 송신 측에서는 생성 다항식을 사용하여 확장 데이터를 만들어 원래 데이터 뒤에 붙인 뒤 이를 생성 다항식과 XOR 연산하여 나머지가 0이 되도록 전송한다. 수신 측에서는 생성 다항식으로 전달받은 데이터를 XOR 연산 하여 나머지가 0이라면 정상, 아니며 오류를 판단한다. 다항식의 복잡도에 따라 검출 능력이 향상되며 다중 오류 역시 해결해준다. 가장 보편적인 오류 검출 방법이며 오류 수정은 여전히 불가능하다.

>> 체크섬
>>> 송신 측은 패킷을 일정 비트마다 구간을 나누고 그 구간의 합을 추가로 보낸다. 수신 측은 마지막 수를 제외한 수들의 합이 마지막 수(체크섬)와 같은지 비교하여 ㅇ오류를 검사한다. 간단한 오류 검사 알고리즘으로 상위 계층에서 더 많이 사용된다.

>> 해밍코드
>>> 
> ## 단위화
> 데이터그램에 헤어와 트레일러를 붙여 캡슐화 하는 작업으로 이때 MAC 주소를 포함하며 이를 이용해 출발지 및 목적지를 알 수 있다.
>> MAC 주소
>> 디바이스 고유의 주소로 네트워크 카드에 저장되어 있다. LAN에서 출발지 및 목적지를 식별하는데 사용된다.
> ## 흐름 제어
> 송신 처리가 수신 처리보다 빠르다면 수신 버퍼가 가득 차고 버퍼 큐에서는 데이터를 버리므로 데이터 손실이 일어날 수 있다.
> 데이터 링크 계층에서는 이러한 데이터 간 송수신 간의 속도 차이 해결을 위해 흐름 제어를 지원하여 효율적 데이터 전송을 보장한다.
>> 정지-대기
>>> 송신 측이 프레임(데이터)을 보내면 수신 측은 ACK로 확인하며 데이터를 전부 전송했다면 EOT로 완료한다. 이는 상당히 비효율적이다.

>> 슬라이딩 윈도우
>>> 송신 측과 수신 측이 각각의 윈도우(받을 수 있는 패킷의 최대 개수)크기를 지정한다. 수신 측은 ACK로 응답하며 오류 발생 시 NAK로 재응답 요청을 요구한다. 송신 측은 ACK를 받을 때마다 윈도우를 슬라이드 하여 다음 패킷을 전송한다. NAK를 받는다면 윈도우는 슬라이드 하지 않는다. 윈도우 크기만큼 패킷을 보내므로 효율적이고 오류 발생 시 재전송 기능이 있기에 신뢰할 수 있다. 

> 대표 장비로는 브리지, 스위치 등이 있다.

## Network (3계층)

## Transport (4계층)

## Session (5계층)

## Presentation (6계층)

## Application (7계층)

## 프로토콜
> 데이터 통신 방법을 통일시키기 위해 약속한 규칙. HTTP/HTTPS, Telnet, SSH 등이 있다.

## 라우터
>

## IP

## IP 주소 클래스

## 브로드캐스트

## 서브넷

## 서브넷마스크

## 스위치

출처 : https://brunch.co.kr/@toughrogrammer/16
