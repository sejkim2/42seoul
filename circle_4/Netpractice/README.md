# Netpractice

## 컴퓨터 네트워크
> 분산되어 있는 컴퓨터를 통신망으로 연결하여 통신하는 것을 말한다. 각각의 컴퓨터 (호스트)는 통신 프로트콜이라는 규칙 시스템을 지키며 물리적 또는 무선 기술(유선 및 무선 통신)을 통해 데이터를 교환한다.

## 컴퓨터 네트워크 아키텍처
> 컴퓨터 네트워크 아키텍처 설계는 두가지로 나뉘며 client-server 구조 혹은 p2p 구조를 따른다.

> client-server 구조 : 서버는 클라이언트들이 필요한 리소스를 제공하며 연산 처리 기능도 맡는다. 클라이언트끼리는 서로 통신이 가능하지만 리소스를 공유하지는 않는다. 즉, 데이터 엑세스는 서버를 통해서만 가능하다.

> p2p 구조 : 서버와 클라이언트의 구분이 없으며 (피어라고 부른다) 각 피어는 동등한 권한을 가지고 리소스 공유 역시 피어끼리 진행한다.

> 차이점 : 클라이언트-서버 구조에서는 클라이언트의 수가 많을 경우 병목 현상(특정 클라이언트에서의 자원 처리가 늦을 경우 다른 클라이언트의 자원 처리 시간에 영향을 끼침)가 일어날 수 있지만 p2p 구조는 서버가 피어 수만큼 있기 때문에
연산 작업이 분산되어 병목 현상이 적다. 안전성 면에서는 검증된 서버에 의해 리소스를 제공받고 접근 기록을 관리받는 클라이언트에 비해 p2p 구조에서는 사용자끼리 리소스를 주고 받으므로 보안적 측면에서 위험하다고 볼 수 있다.

> <img width="759" alt="스크린샷 2024-01-31 오후 10 46 13" src="https://github.com/sejkim2/42seoul/assets/128696540/c8b8c033-c264-429b-9ab7-c2b79d9e5f67">

## 호스트
> 컴퓨터 네트워크에 연결된 컴퓨터, 즉 서로 통신이 가능한 컴퓨터를 말한다. (출처 : http://www.codns.com/b/B05-156)

## OSI 7 계층, IP/TCP 4 계층
> <img width="359" alt="스크린샷 2024-01-31 오후 11 28 36" src="https://github.com/sejkim2/42seoul/assets/128696540/12962687-d332-4f6e-b81c-862c9b4d6096">

> 네트워크 관리를 독립적으로 운영하기 위해 국제표준화기구에서 개발한 네트워크 표준 모델이다. (각 계층은 다른 계층에 영향을 주지 않으며 이는 유지 보수에 유리하다.)

## Physical (1계층)
> 논리 데이터를 물리적으로 전송하는 계층, 하드웨어적 기술이 주를 이루고 있다.
> 대표적인 장비로는 리피터, 허브 등이 있다.

> ## 리피터
> 케이블이 길수록 신호가 약해지기 때문에 신호를 증폭시키기 위한 장치이며 구조가 단순하다.
> 허브에 리피터 기능이 있기에 잘 쓰이지 않는다.

> <img width="643" alt="Screen Shot 2024-02-01 at 6 05 40 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/7994ca6f-2338-4165-a2f8-ac29e679feb0">

> ## 허브
> 리피터의 역할을 하지만 여러 장비와 연결 가능하다.
> 한정된 장소에서(같은 레벨) 여러 컴퓨터를 연결할 때 사용된다. (ex : 벽의 랜선을 6포트 허브에 연결하여 5대의 컴퓨터가 사용)
> 주소를 고려하지 않는 브로드캐스트 전송 방식을 사용하며 출발지와 목적지에 대한 정보를 가지고 있지 않다.
> 허브는 데이터를 연결된 모든 기기에 전달(브로드캐스트)하기 때문에 동시 전송 시 데이터 충돌이 일어날 수 있다. (콜리전)
> 모든 포트 간 대역폭을 나누어 사용하기 때문에 연결된 기기가 많을 수록 성능 저하가 발생한다.
> MAC 주소 기반으로 데이터를 전송하는 스위치의 등장으로 허브는 현재 소규모 네트워크에서만 사용된다.

> <img width="461" alt="Screen Shot 2024-02-01 at 6 08 33 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/04bfeefa-701a-477b-a588-ccf9ff131359">

<hr/>

## Datalink (2계층)
> 물리 계층에서 전달받은 데이터의 주소를 할당하고 물리 계층에서 발생할 수 있는 오류를 찾아 수정하여 재전송한다.
> ## 에러 제어
>> 페리트 비트
>>> 1의 개수를 짝수 개로 맞춰 보낼지(짝수 페리티) 홀수 개로 맞춰 보낼지(홀수 페리티) 송/수신 측이 약속하여 그에 맞게 페리트 비트를 채워 보내 바뀐 비트가 있는지 확인하는 방법. 2bit 이상의 손실 시 홀수와 짝수 검사 의미가 없으며(정확히는 짝수 개일 경우 알 수가 없다) 오류가 발생한 위치를 알 수 없으므로 수정 또한 불가능하다.

>> CRC(순환 중복 검사)
>>> 송신 측에서는 생성 다항식을 사용하여 확장 데이터를 만들어 원래 데이터 뒤에 붙인 뒤 이를 생성 다항식과 XOR 연산하여 나머지가 0이 되도록 전송한다. 수신 측에서는 생성 다항식으로 전달받은 데이터를 XOR 연산 하여 나머지가 0이라면 정상, 아니며 오류를 판단한다. 다항식의 복잡도에 따라 검출 능력이 향상되며 다중 오류 역시 해결해준다. 가장 보편적인 오류 검출 방법이며 오류 수정은 여전히 불가능하다.

>> 체크섬
>>> 송신 측은 패킷을 일정 비트마다 구간을 나누고 그 구간의 합을 추가로 보낸다. 수신 측은 마지막 수를 제외한 수들의 합이 마지막 수(체크섬)와 같은지 비교하여 오류를 검사한다. 간단한 오류 검사 알고리즘으로 상위 계층에서 더 많이 사용된다.

>> 해밍코드
>>> 패킷 하나에 충분한 페리티 비트를 추가하여 오류 검출 및 수정이 가능한 알고리즘이다. [2^p - 1 >= d + p + 1](단, p는 페리트 비트 수, d는 데이터 비트 수)에 의해 페리트 비트 수가 결정되며 2^n의 위치마다 페리트 비트가 배치되며 데이터는 그 사이에 배치된다. 각 위치에 배치된 페리트 비트는 자신이 관리하는 영역의 비트들에서 오류가 있는지 검사한다. 오류 위치를 알기 때문에 수정 또한 가능하다.

> ## 단위화
> 데이터그램에 헤어와 트레일러를 붙여 캡슐화 하는 작업으로 이때 MAC 주소를 포함하며 이를 이용해 출발지 및 목적지를 알 수 있다.
>> MAC 주소
>> 디바이스 고유의 주소로 네트워크 카드에 저장되어 있다. LAN에서 출발지 및 목적지를 식별하는데 사용된다.

> ## 흐름 제어
> 송신 처리가 수신 처리보다 빠르다면 수신 버퍼가 가득 차고 버퍼 큐에서는 데이터를 버리므로 데이터 손실이 일어날 수 있다.
> 데이터 링크 계층에서는 이러한 데이터 간 송수신 간의 속도 차이 해결을 위해 흐름 제어를 지원하여 효율적 데이터 전송을 보장한다.
>> 정지-대기
>>> 송신 측이 프레임(데이터)을 보내면 수신 측은 ACK로 확인하며 데이터를 전부 전송했다면 EOT로 완료한다. 이는 상당히 비효율적이다.

>> 슬라이딩 윈도우
>>> 송신 측과 수신 측이 각각의 윈도우(받을 수 있는 패킷의 최대 개수)크기를 지정한다. 수신 측은 ACK로 응답하며 오류 발생 시 NAK로 재응답 요청을 요구한다. 송신 측은 ACK를 받을 때마다 윈도우를 슬라이드 하여 다음 패킷을 전송한다. NAK를 받는다면 윈도우는 슬라이드 하지 않는다. 윈도우 크기만큼 패킷을 보내므로 효율적이고 오류 발생 시 재전송 기능이 있기에 신뢰할 수 있다. 

> 대표 장비로는 브릿지, 스위치 등이 있다.
>> 브릿지
>>> 1계층의 주요 장비인 허브는 브로드캐스팅 방식으로 데이터를 전송하기 때문에 많은 충돌(콜리전)을 일으킬 수 있고 연결된 노드가 많을수록 성능 저하가 발생한다. 브릿지는 각각의 포트 간 독립적인 콜리전 도메인을 형성하여 충돌을 줄여준다. 또한 MAC 주소를 사용하여 목적지를 식별할 수 있기 때문에 특정 세그먼트에게 데이터를 전송하는 것이 가능하다. 전송 방식은 store-and-forward 방식을 채택하고 있다.

>>> store-and-forward(저장 후 전달) : 포트로 프레임을 전부 받은 다음 에러 또는 목적지 주소를 확인하는 방식이며 에러 발생 시 해당 패킷을 버리고 재전송을 요구한다. 프레임을 전부 받고 확인하기 때문에 전송 지연이 발생할 수 있다.

>>스위치
>>> 스위치는 패킷 처리에 있어 소프트웨어적으로 처리되는 브릿지와 달리 하드웨어적 동작 방식을 사용하게 때문에 속도가 더 빠르다. 브릿지보다 더 많은 포트를 가질 수 있으며 전송 방식 역시 다양하다. MAC 주소를 학습하는 기능도 있어 이미 통신한 주소에 대해서 효율적인 전송이 가능하다.

>>> cut-throught : 목적지 주소를 먼저 확인하고 프레임을 해당 목적지까지 전송을 즉시 시작하며 속도는 빠르지만 프레임 손실이 발생할 가능성이 있다.

>>> Fragment-free : cut-throught 방식에서 처음에 확인하는 비트 수를 늘린 방식이며 프레임 전체를 확인하지 않으면서 안전하게 빠른 속도로 전송이 가능하다.

<hr/>

## Network (3계층)
>> 데이터 링크 계층에서 흐름 제어 및 오류 검사가 이루어진 데이터는 네트워크 계층에서 라우팅을 통해 목적지로 가는 최적의 경로를 결정하고 전송 계층으로 넘겨주는 역할을 한다.
>> 대표 장비는 라우터가 있다.
>> 3계층에서 사용되는 프로토콜은 대표적으로 IP(인터넷 프로토콜)가 있다.
>> 3계층에서 지원하는 주요 기능은 포워딩과 라우팅이 있다.

> ## 라우터
>> 컴퓨터 네트워크 간에 패킷을 전송하는 네트워크 장치이며 라우팅 알고리즘에 따라 패킷이 이동할 최상의 경로를 설정해준다.

> ## 포워딩
>> 패킷이 라우터의 입력 링크에 도달하고 출력 링크까지 전달되는 것을 말한다.
>> 데이터 평면에서 실행되며 하드웨어 위에서 돌아가기 때문에 속도가 빠르다.
> ## 라우팅
>> 송신자 호스트로부터 수신자 호스트까지의 경로 결정을 말한다. (경로는 라우팅 알고리즘을 통해 계산된다.)
>> 제어 평면에서 실행되며 소프트웨어 위에서 돌아가기 때문에 속도가 포워딩에 비해서는 느리다.
> ## SDN(Software Defined Network)
> <img width="559" alt="Screen Shot 2024-02-05 at 2 59 38 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/ce1b9a14-c22a-44b0-b638-fa08556c11e0">
> <img width="685" alt="Screen Shot 2024-02-05 at 3 03 16 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/a23871da-8b04-4224-853f-f813adff2d27">

>> 소프트웨어를 통해 네트워크 리소스를 추상화하고 중앙에서 전체 네트워크를 제어 및 관리하는 것이다.

>> SDN의 구조는 제어 평면(제어부, 소프트웨어)과 데이터 평면(전송부, 하드웨어)으로 나뉘며 기존 라우터는 두 평면이 같이 존재하였다. 해드웨어 영역에서 실행되는 포워딩과 비교했을 때 소프트웨어 단에서 실행되는 라우팅의 속도가 느렸기 때문에 이러한 오버헤드를 분리하여 관리하기 위해 SDN이 도입되었다. SDN의 도입으로 두 평면이 분리되면서 각 라우터가 포워딩 테이블을 가지고 있지 않고 제어 평면에서 해당 작업을 수행하며 라우터는 데이터 전송 기능만 담당하도록 변화하였다. 이로 인해 각 장비는 해당 기능에만 최적화가 가능하게 되어 기존 하드웨어 중심의 네트워크에 비해 유연한 구조를 가지게 되었다.

> ## 라우터의 내부 구조
>> <img width="926" alt="Screen Shot 2024-02-05 at 3 31 24 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/50e92c25-494c-4aaa-8102-8dafd310fd31">

>> 스위칭 구조(Switching Fabrics)
>> 라우터의 입력 포트와 출력 포트를 연결하는 역할을 하며 라우터의 핵심이라 볼 수 있다.
<img width="902" alt="Screen Shot 2024-02-05 at 4 17 26 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/6e74a36d-9b7d-4c69-88fa-6b8059163f8c">

>>> 메모리를 통한 교환 : 초기 라우터는 라우팅 프로세서를 직접 제어하여 패킷을 스위칭 하였다. 이는 한번에 하나의 메모리 읽기/쓰기 작업이 수행되기 때문에 동시에 2개의 패킷을 전달할 수 없었다.

>>> 버스를 통한 교환 : 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다. 라우팅 프로세서를 거치지 않으므로 읽기/쓰기 작업 시간을 아낄 수 있지만 버스를 통과할 수 있는 패킷은 오직 하나이므로 다른 패킷은 대기해야 하므로 라우터의 교환 속도는 버스 속도에 의해 제한된다.

>>> 크로스바를 통한 교환 : 기존의 버스가 N개인 것에 반하여, 크로스바 스위치는 2N버스로 구성된 상호연결 네트워크로 멀티프로세서 컴퓨터 구조와 비슷한 형태를 보여주고 있다. 여러 패킷을 병렬로 처리 가능하지만 서로 다른 포트에서 나오는 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 버스에서 전송 가능하기 때문에 여전히 지연이 발생할 수 있다.

>> 입력 포트는 포워딩 테이블(제어 평면의 라우팅 프로세서에 존재)을 사용하여 도착한 패킷의 출력 포트를 결정한다. 그 후 스위치 구조에 패킷을 보내주는데 스위치 구조의 처리속도와 입력 포트의 처리 속도에 차이가 생기면 앞의 패킷이 뒤의 패킷을 막는 HOL Blocking 현상이 일어나 wait에 걸려 트래픽이 발생하거나 패킷 손실 및 재전송이 일어날 수 있다.(queueing)
>> 입력 큐잉은 스위치 구조의 속도 변경으로 해결 가능하지만 출력 큐잉은 나가는 속도(전송룔)가 고정되어 있기 때문에 다른 방법을 사용해야 한다. 알려진 바로는 패킷이 어떤 링크에 보내질지 스케줄링을 하는 작업이 필요하다.

>>> FCFS : 선입선출 방식으로 패킷 전송 순서를 지정한다.

>>> Priority Queue : 우선순위를 지정하여 패킷을 전송한다. (우선순위 지정 때문에 특정 패킷이 계속 전송되지 못하는 기아 상태에 빠질 수 있다.)

>>> RR (Round Robin) : 패킷마다 일정한 시간을 부여하고 순서대로 전송으로 처리한다. 공정성이 높지만 순서대로 전송을 처리하는 과정은 스위칭이 빈번하게 일어난다는 뜻이므로 비효율적이다.

>>> WFQ (Weighted Fair Queueing) : 라운드 로빈의 단점을 보완하고자 가중치에 따른 서로 다른 시간을 패킷에게 부여하여 전송을 처리한다.

## IP(Internet Protocol)
>> 읽어보면 좋은 레퍼런스 : https://www.akamai.com/ko/glossary/what-is-an-ip-address

>> 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용되는 프로토콜이다. 쉽게 말해, 인터넷 상에서 데이터를 주고받는 데 사용되는 주소 체계라 보면 된다. 자세하게는, 호스트의 주소 지정과 패킷 분할 및 조립 기능을 담당한다. 버전은 IPv4와 IPv6이 있으며 특징으로는 비신뢰성, 비연결성, 프로세스 구분x 등이 있다. IP의 특징이 가지는 단점을 보완하기 위해서 4계층의 tcp와 같은 프로토콜과 같이 사용된다.
> ## IP Header
<img width="820" alt="Screen Shot 2024-02-06 at 5 43 35 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/8f8fb512-c13f-4a51-8062-f7a2729771b1">

>>> TOS는 서비스 타입으로 패킷 처리의 우선순위를 지정하거나 서비스 품질 설정, 패킷 신뢰성 표시 등을 담당한다. (여기서 설정하는 신뢰성은 기능에 대한 것은 아니고 상위 레이어에서 젇책 설정에 도움을 주는 플래그 정도로 이해하면 된다.)

>>> total length : 헤더와 데이터를 더한 길이.

>>> identification : 식별자로 패킷 고유의 번호를 지정한다. 이는 2계층에서 분할된 패킷이 재조립할 때 기준이 된다.

>>> flags : 식별자 옆에 있는 1bit 필드로 해당 층의 32bit 필드들은 모두 단편화(분할 후 재통합)와 관련이 있다.

>>> TTL : 라우팅 루프(네트워크에서 테이터그램이 무한히 순환하는 현상)를 해결해주는 필드로 라우터는 데이터그램을 처리할 때마다 해당 필드를 감소시키며 0이 되면 해당 데이터그램을 폐기한다.

>>> 헤더 체크섬 : 라우터가 수신한 IP 헤더의 비트 오류를 탐지하는 필드. (IP 데이터그램에 대한 오류 검사는 tcp/udp에서 이루어진다.)

>>> 데이터(페이로드)

> ## IPv4
>>> 8bit(0~255, 1byte) 4개로 이루어진(각 단위는 옥텟이라 부른다) 32bit 주소 쳬계로 이후 주소 부족으로 인해 IPv6가 나오게 되었다.
> ## IPv6
>>> 16bit 8개로 이루어진 128bit 주소 체계로 기존 IPv4 체계에서 전환이 전부 이루어지진 않았지만 더 많은 주소 할당이 가능해져서 실행활에서 사용하는 대부분의 기기에 IP 할당이 가능해졌다.
> ## 비신뢰성
>>> 송신 호스트에서 수신 호스트로의 패킷 전달 과정에서 발생하는 패킷 소실에 대해 책임을 지지 않는댜. 또한 전송 과정에서 패킷의 크기가 클 경우 여러개의 패킷으로 나누어 전송을 시도하는데, 이때 수신 호스트로 도착하는 패킷 조각들의 순서는 보장되지 않는다.
> ## 비연결성
>>> 송신 호스트는 수신 호스트의 상태는 알지 못하고 주소만 파악하여 일단 패킷을 전송하며 수신 호스트가 패킷을 잘 전달받았는지 확인하지 않는다.
> ## 프로세스 구분x 
>>> 같은 IP를 사용하는 서버에서 통신하는 어플리케이션의 경우 어떤 프로세스인지 구분할 수 없다.

## IP 주소 클래스
>> IP 주소는 하나의 네트워크 안에 있는 IP들은 네트워크 영역(해당 주소가 속한 네트워크를 지정)은 같아야 하고, 호스트 IP(네트워크 내 장치를 지정)는 서로 달라야 통신이 가능하다. 이때 네트워크 영역은 클래스에 따라 크기가 변경되며 하위 클래스로 갈수록 사용 가능한 크기가 줄어든다. 각각의 네트워크 주소는 1, 2, 3 byte로 제한되며 이러한 고정된 주소 할당은 급속도로 증가하는 기관의 수를 지원하기에는 효율 상 문제가 있었다. 예를 들어, C 클래스의 경우 /24 서브넷은 2^8-2의 254개 호스트만을 지원가능하며 이는 많은 조직을 위해서는 턱없이 부족하다. 2000개 이상의 호스트 사용 시 B 클래스를 할당받는데, /16 서브넷은 2^16-2의 65634개 호스트를 제공하하므로 약 63000개의 호스트 주소 낭비로 이어진다. 현대의 인터넷 주소 할당 방식은 유연한 주소 할당 체계를 위해 CIDR 주소 체계를 채택하고 있다.
<img width="842" alt="Screen Shot 2024-02-06 at 7 18 05 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/409eca1a-4ccf-4f60-bb8a-988e2ae61344">

(D, E 클래스는 멀티캐스트, 연구 용이므로 제외함)

> ## A 클래스
>> 32bit 2진수로 표현되었을 때 항상 맨 앞자리가 0인 주소 (0xxx xxxx. xxxx xxxx. xxxx xxxx. xxxx xxxx)이며 첫 옥텟이 네트워크 주소이고 나머지는 호스트 주소이다. 네트워크 주소의 범위는 127개이며, ([0xxx xxxx.] xxxx xxxx. xxxx xxxx. xxxx xxxx 에서 [] 안의 범위 2^7 - 1, 127은 제외하기로 약속)이며 호스트 주소의 범위는 2^(32-8) - 2개이다. (0xxx xxxx. [xxxx xxxx. xxxx xxxx. xxxx xxxx] 에서 [] 안의 범위 2^24 - 2, 0.0.0.0은 네트워크 주소, 모두 1인 경우는 브로드캐스트이므로 제외)

> ## B 클래스
>> 10으로 시작하는 주소이며 네트워크 범위는 2^14개 (10[xx xxxx. xxxx xxxx.] xxxx xxxx. xxxx xxxx)이고 호스트 주소의 범위는 2^16 - 2개 이다.(10xx xxxx. xxxx xxxx. [xxxx xxxx. xxxx xxxx], 브로드캐스트, 네트워크 주소 제외)

> ## C 클래스
>> 110으로 시작하는 주소이며 네트워크 범위는 2^21개 (110[x xxxx. xxxx xxxx. xxxx xxxx.] xxxx xxxx)이고 호스트 주소의 범위는 2^8 -2개 이다.(10xx xxxx. xxxx xxxx. xxxx xxxx. [xxxx xxxx], 브로드캐스트, 네트워크 주소 제외)

## CIDR(Classless InterDomain Routing)
>> IP 주소를 클래스로 분류하여 고정 할당한 IP 주소 클래스 체계와 달리 CIDR 주소 체계는 네트워크 용도에 따라 서브넷의 크기를 유연하게 변경할 수 있어 주소 할당에 효율적이다. 32비트 IP 주소는 두 부분으로 나뉘고 이것은 다시 점으로 된 십진수 형태의 a.b.c.d/x를 가지며 여기서 x는 주소 첫 부분의 비트 수이다. 최상위 비트(MSB, most significant bit)를 의미하는 x는 IP 주소의 네트워크 부분을 구성하며 프리픽스라고 부른다. 한 기관은 공통 프리픽스 블록을 할당받으며 외부 기관 라우터는 내부 기관으로 데이터를 전달할 때 프리픽스만 고려하면 된다. 이는 라우터에서 포워딩 테이블의 크기를 상당히 줄여주므로 효율적이다. 나머지 주소(32-x) 비트들은 기관 내부에 같은 프리픽스를 갖는 장비(호스트)를 구별한다. 즉, 기관 내부의 라우터에서 패킷을 전달할 때 사용된다. 

<hr/>

## Transport (4계층)

<hr/>

## Session (5계층)

<hr/>

## Presentation (6계층)

<hr/>

## Application (7계층)

<hr/>

## 프로토콜
> 데이터 통신 방법을 통일시키기 위해 약속한 규칙. HTTP/HTTPS, Telnet, SSH 등이 있다.

## 브로드캐스트

## 서브넷
<img width="437" alt="Screen Shot 2024-02-13 at 1 30 19 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/3709a222-bc52-470b-b903-658fbce24b09">

>> 네트워크 내부에 있는 네트워크로 이러한 짧은 거리 내를 이동할 때는 라우터를 거치지 않고 직접 도달할 수 있기 때문에 네트워크 트래픽을 줄일 수 있고 이는 네트워크를 효율적으로 만든다. (서로 다른 서브넷 간에는 라우터 통신이 이루어짐) 네트워크 클래스 관점으로 본다면, 예를 들어 A 클래스에 속하는 주소가 있다면 해당 주소를 찾기 위해 많은 시간이 걸릴 수 있지만 서브넷를 사용한다면 IP 주소를 장치 범위 내에서 사용하도록 좁혀준다. 이러한 관점에서 효율적인 주소 할당을 위해 나온 개념이 바로 서브넷으로 IP 주소를 네트워크 부분과 호스트 부분으로 나누어 관리한다. 서브넷을 사용하므로서 네트워크를 분리하여 관리할 수 있고 이는 트래픽을 줄이며 보안을 강화하는 효과를 가져온다. 

## 서브넷마스크
>> 

## LAN(Local Area Network)
>> <img width="696" alt="Screen Shot 2024-02-03 at 8 48 55 PM" src="https://github.com/sejkim2/42seoul/assets/128696540/0a0072bd-ab24-4a6d-92a0-954a375f4a38">

>> 같은 건물 내에 있는 근거리 통신망으로 대표적 LAN의 예시로는 Wi-Fi를 들 수 있다. 보통은 라우터를 통해 인터넷에 연결하지만 규모가 있는 공간에서는 효율적인 패킷 전달을 위해 추가로 스위치를 사용한다.

## 게이트웨이
>> 한 네트워크 네에서 다른 네트워크(서로 다른 통신망, 프로토콜)로 통신을 할 때 거쳐가는 관문.

>> 출처 : https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-lan/
>> 출처 : https://brunch.co.kr/@toughrogrammer/16
>> 출처 : https://velog.io/@hsshin0602/%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-SDNSoftware-Defined-Network
>> 출처 : https://east-star.tistory.com/23
>> 출처 : https://onecoin-life.com/19
>> 출처 : https://limkydev.tistory.com/168
>> 출처 : https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-subnet/#:~:text=%EC%84%9C%EB%B8%8C%EB%84%B7%2C%20%EC%A6%89%20%EC%84%9C%EB%B8%8C%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EB%8A%94%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EB%82%B4%EB%B6%80%EC%9D%98%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9E%85%EB%8B%88%EB%8B%A4,%EC%97%90%20%EB%8F%84%EB%8B%AC%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.
